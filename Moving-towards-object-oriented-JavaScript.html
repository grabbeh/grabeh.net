<!DOCTYPE html>



<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Grabeh.net</title>
    <link rel="stylesheet" href="https://unpkg.com/tachyons@4.7.0/css/tachyons.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
    <link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/dracula.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <style>
        body {
            font-family: 'Roboto', serif;
        }

        .grey {
            color: rgba(0, 0, 0, .4)
        }
    </style>
</head>

<body class="bg-light-red" id="container">
    <div class="pa2 f5 bg-white mb4 tc w3 shadow-5">
        <a class="b link black underline-hover" href='/'><i class="fa fa-home fa-2x" aria-hidden="true"></i></a>
    </div>
    <div class="pl5-l pr5-l mh4-ns mh2">
        <div class="fl w-70-l w-100">
            <div class="cf shadow-5 mb3 pa3 bg-white">
                <div class="f2 b">Moving towards object-oriented JavaScript</div>
            </div>
            <div class="mb4-l shadow-5 bg-white ph5-ns ph3 pv1">
                <div class="f4-ns f5 w-100  lh-copy">
                    <p></p>
                    <div class="quote">971 additions and 3,493 deletions</div>
                    <p>The above statistic from Github from the repository for one of my apps <a href="https://github.com/grabbeh/routebop">Routebop</a>                        showing the changes to the repo following a few days of editing is gratifying to me<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>.</p>
                    <p>Whilst as a beginner you would normally code to improve or build a new feature, a user of the site would
                        not notice any change to the functionality of the site following the above changes.</p>
                    <p>So on the basis that you'd normally change code to alter functionality, what actually changed? </p>
                    <p>When I initially built the site because I had a fear of cross-contamination of JS amongst different pages,
                        and because I was (and still am in many ways) a beginner, I decided to place all the JavaScript necessary
                        for each page in the page itself with no sharing of JS between pages at all. As functionality between
                        pages is shared to an extent, this meant that there was a significant amount of duplication<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>.
                    </p>
                    <p>However, the extent of duplication meant that there was always a nagging feeling that switching from
                        the JS-per-page approach to one using separate JS files would lead to a much cleaner approach and
                        allow for an easier time in updating functionality in the future.</p>
                    <p>When I decided to refactor the code I first selected the page which I felt had the most functionality
                        that I could potentially share across other pages. Following this, still within the same page I split
                        up functions where I could. For example, one function collects and converts markers and waypoints
                        into a more basic form, POSTs to the server, and then responds with a success message. </p>
                    <p>On the basis that the POSTing to the server element would be repeated, I split out this functionality
                        and put a small wrapper around it to pass through transaction specific arguments into the function
                        as follows:</p>
                    <pre><code class="f5">
this.sendToServer = function(postdata, posturl, completefunction){
$.ajax({
    url: posturl,
    type: "POST",
    contentType: "application/json",
    processData: false,
    data: JSON.stringify(postdata),
    success: completefunction
    });
};
this.sendToServer(postdata, "/show", function(data){
    $('#result').html(data.message);
    });
};
</code></pre>
                    <p>This way, the function could be re-used passing in different arguments depending on what was necessary
                        in the circumstances. In respect of the 'completefunction' and as per the above I use an anonymous
                        function when the function is actually called to specify what will happen when the POST request is
                        successful (displaying a success message, or processing the data onto a map for example).</p>
                    <p>Following this point, I then started work on a separate JavaScript file switching across functions from
                        the page itself into the JS file. I adopted a rather timid approach to this initially, switching
                        over a function or two, then making reference to them in the HTML file to ensure things were still
                        working.
                    </p>
                    <p><strong>Design patterns you say?</strong></p>
                    <p>I do have a copy of <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">Design Patterns</a>                        by Addy Osmani on my bookshelf at home, however, on flipping through the book, I suspect the pattern
                        I've used is somewhere between Constructor and the module pattern.</p>
                    <p>Essentially, this means that to use the JavaScript I create an instance of the Constructor by using the
                        'new' keyword and then attach that to a variable when opening a particular page. I think in part
                        this is inspired by Google Maps which uses the new keyword when instantiating a new map or map-related
                        item ilke a marker or infowindow.</p>
                    <p>At the same time as creating a public interface using 'new', I also included local variables within the
                        Constructor which are only able to be accessed by public methods on the instance. An example is as
                        follows:
                    </p>
                    <pre><code class="f5">
function Map(){
    var mapmarkers = [];
    this.returnMapMarkers = function(){
    	return mapmarkers;
    }; 
    this.addMarkersToMap = function(array){
    // function to place marker on map & push into mapmarkersarray
    };
};

// Instantiation

var map = new Map;

map.mapmarkers;
>> undefined

map.returnMapMarkers()
>> [ array of markers ]

</code></pre>
                    <p>In this way, the mapmarkers private variable can only be accessed and updated using public methods (as
                        I understand it).<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>.</p>
                    <p><strong>Limitations on code re-use</strong></p>
                    <p>In the process of refactoring the code, there were times when in the current state, I couldn't re-use
                        the code across pages. At this point, I had to create new functions which although very similar in
                        nature to existing functions performed slightly differently. </p>
                    <p>This was definitely a lazy way of doing things, and in future, I hope to do more work in stripping down
                        functions into their component parts to ensure a greater ability to re-use functionality.</p>
                    <p><strong>Separation of functionality</strong></p>
                    <p>In addition to the main map.js file I also created separate files to cover distinct functionality on
                        the site. This includes image upload handling and geocoding. I think this is a fairly common practice.
                        As part of this, I created a init() function which is then the only function called to add the functionality
                        to the page, as it incorporates calls to all the necessary functions.</p>
                    <p>In summary, when it comes to code refactoring, I don't really know what I doing. However although the
                        above may not be (i) the most efficient in terms of code re-use or (ii) implement a design pattern
                        correctly, it is definitely a leap forward for me from the JS-per-page approach used previously.</p>
                    <p>In future I hope to use the code I've written to help me improve my usage of design patterns and write
                        better JavaScript generally.</p>
                    <div class="footnotes">
                        <hr>
                        <ol>
                            <li id="fn1">
                                <p>Particularly on the basis that the total repo size was only 20k lines of code before the
                                    changes.
                                    <a href="#fnref1" rev="footnote">↩</a></p>
                            </li>

                            <li id="fn2">
                                <p>On the other hand, one slight benefit was that altering JS on one page would only affect
                                    the functionality on that page. This form of sand-boxing helped to provide comfort that
                                    making changes to the page on the basis that it would not break another page. <a href="#fnref2"
                                        rev="footnote">↩</a></p>
                            </li>

                            <li id="fn3">
                                <p>One point that does need addressing is that usually you would define static methods on the
                                    prototype of the Constructor rather than directly using 'this'. This is because by using
                                    prototype methods are automatically shared on all instances of the constructor, whereas
                                    with 'this' each method is defined afresh when a new instance is created with 'new'.
                                    I'll be updating this in the future (although in fairness multiple instances are not
                                    created on the site (for example only one 'Map' instance is created per page)). <a href="#fnref3"
                                        rev="footnote">↩</a></p>
                            </li>

                        </ol>
                    </div>
                </div>
            </div>
        </div>
        <div class="mb3 mt0-l mt3 pl4-l fl w-30-l w-100">
            <div class="bg-white f4 pa3 shadow-5">
                <ul class="pa0 ma0 list">
                    <li class="pv1"><a class="underline link black" href="https://twitter.com/grabbeh"><i class="mr2 fa fa-twitter "aria-hidden="true"></i>Twitter</a></li>
                    <li class="pv1"><a class="underline  link black " href="https://github.com/grabbeh"><i class="mr2 fa fa-github" aria-hidden="true"></i>GitHub</a></li>
                    <li class="pv1"><a class="underline  link black " href="/about"><i class="mr2 fa fa-user" aria-hidden="true"></i>About</a></li>
                </ul>
            </div>
        </div>
    </div>
</body>
<script>
    var arr = [
        "bg-red",
        "bg-purple",
        "bg-light-purple",
        "bg-green",
        "bg-navy",
        "bg-dark-blue",
        "bg-blue",
        "bg-light-blue",
        "bg-lightest-blue",
        "bg-light-pink",
        "bg-light-yellow",
        "bg-light-red"]

      /* var color = arr[Math.floor(Math.random()*arr.length)]
      var el = document.getElementById("container")
      el.className = color*/

</script>

</html>